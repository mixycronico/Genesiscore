#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# src/plugins/daily_settlement/processors/settlement_processor.py
"""
settlement_processor.py
Consolida resultados diarios de trading, genera reportes, y actualiza el pool de capital.
"""

from ....core.processors.base import ProcesadorBase
from ....core.entidad_base import Event
from ....utils.logging import logger
from ..utils.db import SettlementDB
import json
import zstandard as zstd
from typing import Dict, Any, List
from datetime import datetime, timedelta
import asyncio

class SettlementProcessor(ProcesadorBase):
    def __init__(self, config: Dict[str, Any], redis_client, db_config: Dict[str, Any]):
        super().__init__()
        self.config = config
        self.redis_client = redis_client
        self.db_config = db_config
        self.logger = logger.getLogger("SettlementProcessor")
        self.settlement_time = config.get("settlement_config", {}).get("settlement_time", "23:59")
        self.circuit_breaker = config.get("config", {}).get("circuit_breaker", {})
        self.plugin_db = None
        self.trading_results = []  # Cachea resultados de trading
        self.capital_movements = []  # Cachea movimientos de capital
        self.macro_context = {}  # Contexto macro
        self.user_data = {}  # Datos de usuarios
        self.failure_count = 0
        self.breaker_tripped = False
        self.breaker_reset_time = None

    async def inicializar(self, nucleus: 'CoreCNucleus'):
        self.nucleus = nucleus
        # Inicializar base de datos
        self.plugin_db = SettlementDB(self.db_config)
        if not await self.plugin_db.connect():
            self.logger.warning("No se pudo conectar a settlement_db, usando almacenamiento temporal")

        # Iniciar tarea de consolidación diaria
        asyncio.create_task(self.daily_settlement())
        self.logger.info("SettlementProcessor inicializado")

    async def check_circuit_breaker(self) -> bool:
        if self.breaker_tripped:
            now = datetime.utcnow()
            if now >= self.breaker_reset_time:
                self.breaker_tripped = False
                self.failure_count = 0
                self.breaker_reset_time = None
                self.logger.info("Circuit breaker reseteado")
            else:
                self.logger.warning("Circuit breaker activo hasta %s", self.breaker_reset_time)
                return False
        return True

    async def register_failure(self) -> None:
        self.failure_count += 1
        if self.failure_count >= self.circuit_breaker.get("max_failures", 3):
            self.breaker_tripped = True
            self.breaker_reset_time = datetime.utcnow() + timedelta(seconds=self.circuit_breaker.get("reset_timeout", 900))
            self.logger.error("Circuit breaker activado hasta %s", self.breaker_reset_time)
            await self.nucleus.publicar_alerta({"tipo": "circuit_breaker_tripped", "plugin": "daily_settlement"})

    async def consolidate_results(self) -> Dict[str, Any]:
        if not await self.check_circuit_breaker():
            return {"status": "error", "message": "Circuit breaker activo"}

        try:
            # Calcular ganancias/pérdidas totales
            total_profit = sum(result.get("profit", 0) for result in self.trading_results)
            total_trades = len(self.trading_results)
            trades_by_symbol = {}
            trades_by_exchange = {}
            for result in self.trading_results:
                symbol = result.get("symbol", "unknown")
                exchange = result.get("exchange", "unknown")
                trades_by_symbol[symbol] = trades_by_symbol.get(symbol, 0) + 1
                trades_by_exchange[exchange] = trades_by_exchange.get(exchange, 0) + 1

            # Obtener estado del pool
            pool_total = await self.plugin_db.get_pool_total()
            active_capital = await self.plugin_db.get_active_capital()
            phase = "unknown"
            for p in self.config.get("capital_config", {}).get("phases", []):
                if p["min"] <= pool_total < p["max"]:
                    phase = p["name"]

            # Calcular ROI y distribuciones
            roi = (total_profit / pool_total) * 100 if pool_total > 0 else 0
            user_distributions = {}
            users = await self.plugin_db.get_users()
            for user_id, contribution in users.items():
                proportion = contribution / pool_total if pool_total > 0 else 0
                user_distributions[user_id] = total_profit * proportion

            # Generar reporte
            report = {
                "date": datetime.utcnow().strftime("%Y-%m-%d"),
                "total_profit": total_profit,
                "roi_percent": roi,
                "total_trades": total_trades,
                "trades_by_symbol": trades_by_symbol,
                "trades_by_exchange": trades_by_exchange,
                "pool_total": pool_total,
                "active_capital": active_capital,
                "phase": phase,
                "user_distributions": user_distributions,
                "macro_context": self.macro_context,
                "timestamp": datetime.utcnow().timestamp()
            }

            # Almacenar reporte
            if self.plugin_db and self.plugin_db.conn:
                await self.plugin_db.save_report(
                    date=report["date"],
                    total_profit=total_profit,
                    roi_percent=roi,
                    total_trades=total_trades,
                    report_data=report
                )

            # Publicar reporte
            datos_comprimidos = zstd.compress(json.dumps(report).encode())
            await self.redis_client.xadd("settlement_data", {"data": datos_comprimidos})

            # Actualizar pool
            await self.redis_client.xadd("capital_data", {
                "data": zstd.compress(json.dumps({
                    "action": "update",
                    "profit": total_profit,
                    "timestamp": datetime.utcnow().timestamp()
                }).encode())
            })

            self.logger.info(f"Reporte diario generado: {report['date']}, ROI: {roi:.2f}%")
            return {"status": "ok", "report": report}
        except Exception as e:
            self.logger.error(f"Error consolidando resultados: {e}")
            await self.register_failure()
            return {"status": "error", "message": str(e)}

    async def daily_settlement(self):
        while True:
            now = datetime.utcnow()
            settlement_time = datetime.strptime(self.settlement_time, "%H:%M").replace(
                year=now.year, month=now.month, day=now.day
            )
            if now >= settlement_time:
                await self.consolidate_results()
                # Resetear cachés
                self.trading_results = []
                self.capital_movements = []
                # Esperar hasta el próximo día
                next_settlement = settlement_time + timedelta(days=1)
                await asyncio.sleep((next_settlement - now).total_seconds())
            else:
                await asyncio.sleep(60)  # Revisar cada minuto

    async def manejar_evento(self, event: Event) -> None:
        try:
            if event.canal == "trading_results":
                result = json.loads(zstd.decompress(event.datos["data"]))
                self.trading_results.append(result)
                self.logger.debug(f"Resultado de trading recibido: {result['profit']}")
            elif event.canal == "capital_data":
                movement = json.loads(zstd.decompress(event.datos["data"]))
                self.capital_movements.append(movement)
                self.logger.debug(f"Movimiento de capital recibido: {movement['action']}")
            elif event.canal == "macro_data":
                self.macro_context = event.datos
                self.logger.info("Datos macro recibidos: %s", self.macro_context)
            elif event.canal == "user_data":
                user_event = json.loads(zstd.decompress(event.datos["data"]))
                user_id = user_event.get("user_id")
                self.user_data[user_id] = user_event
                self.logger.debug(f"Evento de usuario recibido para {user_id}")
        except Exception as e:
            self.logger.error(f"Error procesando evento: {e}")
            await self.register_failure()

    async def detener(self):
        if self.plugin_db:
            await self.plugin_db.disconnect()
        self.logger.info("SettlementProcessor detenido")